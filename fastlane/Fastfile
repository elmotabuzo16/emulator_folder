fastlane_version '2.68.2'

default_platform :android

platform :android do
  before_all do
    ENV['CI_BUILD_TYPE'] = ENV['CI_BUILD_TYPE'] || 'dev'
  end

  desc 'Runs the debug build, unit test, java code coverage and android lint'
  lane :build_and_test do |options|
    phraseapp
    generate_versions_file(
      build_number: options[:build_number]
    )
    assemble_task = options[:assemble_task] || 'assembleVitalityActiveDebug'
    gradle(
      task: "clean #{assemble_task}",
      properties: {
        'buildNumber' => options[:build_number]
      }
    )
    # Disabled until approved to run unit testing in Review build
    # gradle(
    #   task: "clean #{assemble_task} testVitalityActiveDebugUnitTest",
    #   properties: {
    #     'buildNumber' => options[:build_number]
    #   }
    # )
    # coverage_report(flavor: 'VitalityActive', build_type: 'Debug')
    lint(build_type: 'Debug') if options[:include_lint]
  end

  desc 'Runs Android lint to all flavors'
  lane :lint do |options|
    build_type = options[:build_type] || 'Debug'
    gradle(task: "lintVitalityActive#{build_type}")
    gradle(task: "lintSumitomo#{build_type}")
    gradle(task: "lintIgi#{build_type}")
    gradle(task: "lintUkessentials#{build_type}")
  end

  desc 'Creates Java code coverage reports'
  lane :coverage_report do |options|
    flavor = options[:flavor] || 'VitalityActive'
    build_type = options[:build_type] || 'Debug'
    gradle(
      task: 'createJacocoTestReports',
      flags: '--info',
      properties: {
        'buildFlavor' => flavor,
        'jacocoBuildType' => build_type
      }
    )
    report_file = sh(
      'cd .. && find app -type f -name "*.html" | grep jacoco | grep "html/index.html"',
      log: false
    )
    UI.success "Jacoco Report file created: #{report_file}"
  end

  desc 'Runs sonarqube in preview mode'
  lane :sonarqube_preview do
    gradle(
      task: 'sonarqube',
      flags: '--info',
      system_properties: {
        'sonar.analysis.mode' => 'preview',
        'sonar.projectName' => 'Mobile - Android - Vitality Active',
        'sonar.projectKey' => "com.vitalityactive.va:#{git_branch}",
        'sonar.report.export.path' => 'sonar-report.json'
      }
    )
  end

  desc 'Runs sonarqube in publish mode'
  lane :sonarqube_publish do |options|
    gradle(
      task: 'sonarqube',
      properties: {
        'buildFlavor' => 'VitalityActive',
        'jacocoBuildType' => 'Debug'
      },
      system_properties: {
        'sonar.analysis.mode' => 'publish',
        'sonar.projectName' => 'Mobile - Android - Vitality Active',
        'sonar.projectKey' => "com.vitalityactive.va:#{git_branch}",
        'sonar.projectVersion' => options[:sonar_project_version] || get_version_name
      }
    )
  end

  desc 'Pulls strings from PhraseApp'
  lane :phraseapp do
    Dir.chdir '..' do
      sh('PHRASEAPP_CONFIG=./app/src/main/phraseapp.yml phraseapp pull')
      sh('PHRASEAPP_CONFIG=./app/src/sumitomo/phraseapp.yml phraseapp pull')
      sh('PHRASEAPP_CONFIG=./app/src/ukessentials/phraseapp.yml phraseapp pull')
      sh('PHRASEAPP_CONFIG=./app/src/igi/phraseapp.yml phraseapp pull')
    end
  end

  desc 'Cleans fastlane dist/ directory'
  lane :clean_dist do
    UI.message 'Cleaning up fastlane/dist directory..'
    sh 'rm -fr dist && mkdir -p dist'
  end

  desc 'Returns the version classifer according to the git branch'
  lane :get_version_classifer do
    case git_branch
    when 'master', /^release-*/
      'rc'
    else
      'SNAPSHOT'
    end
  end

  desc 'Creates versionCode.txt and versionName.txt using the gradle printVersions task'
  lane :generate_versions_file do |options|
    gradle(
      task: 'printVersions --info',
      properties: {
        # 'versionClassifier' => get_version_classifer,
        'buildNumber' => options[:build_number]
      }
    )
  end

  desc 'Returns the android version name generated by generate_versions_file'
  lane :get_version_name do
    # generated by generate_versions_file lane
    File.open('versionName.txt').read.strip
  end

  desc 'Returns the android version code generated by generate_versions_file'
  lane :get_version_code do
    # generated by generate_versions_file lane
    File.open('versionCode.txt').read.strip
  end

  desc 'Runs the review build'
  lane :review_build do |options|
    # review_build_number = "review.#{options[:build_number]}" || 'review.1'
    review_build_number = options[:build_number] || 1
    build_and_test(
      assemble_task: 'assembleDebug',
      build_number: review_build_number,
      include_lint: true
    )
    if options[:publish_to_s3]
      upload_multiple_builds_to_s3(
        build_number: review_build_number,
        apk_files: lane_context[SharedValues::GRADLE_ALL_APK_OUTPUT_PATHS],
        build_info: options[:build_info]
      )
    end
  end

  desc "For CI use. Get the latest tag according to ENV['CI_BUILD_TYPE']."
  lane :get_latest_tag do
    Dir.chdir '..' do
      latest_tag_number =
        sh("git tag | grep #{ENV['CI_BUILD_TYPE']} | awk -F'.' '{print $NF}' | sort -n | tail -1")
      if !latest_tag_number.empty?
        sh("git tag | grep #{ENV['CI_BUILD_TYPE']} | grep #{latest_tag_number}")
      else
        sh('git rev-parse --short HEAD~1')
      end
    end
  end

  desc 'For CI use. Create a fastlane/FULL_CHANGELOG.md file.'
  lane :make_changelog do |options|
    sh('rm -f *_CHANGELOG.md')
    from_commit = options[:from_commit] || get_latest_tag.strip
    to_commit = options[:to_commit] || last_git_commit[:abbreviated_commit_hash]
    changelog = changelog_from_git_commits(
      between: [from_commit, to_commit],
      pretty: '* %s (%h) via %ae',
      include_merges: false
    )
    File.write('FULL_CHANGELOG.md', changelog)
    sh('./generate_changelogs.sh || true')
  end

  desc 'For CI use. Automatically tags the HEAD commit.'
  lane :tag_current_commit do
    if git_branch == 'master' || git_branch =~ /^release-.*/
      UI.message("Version Number: #{get_version_name}")
      tag_name = "#{ENV['CI_BUILD_TYPE']}/#{get_version_name}"
      add_git_tag(
        tag: tag_name
      )
      push_git_tags
      File.write('tag_name.txt', tag_name)
    end
  end

  desc 'Runs the tasks/lanes needed for releasing ready-for-testing android builds to s3 site'
  lane :production_build do |options|
    clean_dist
    build_number = options[:build_number] || 1
    generate_versions_file(build_number: build_number)
    version_name = get_version_name
    keystore_path = options[:keystore_path] || ENV['ANDROID_KEYSTORE_PATH']
    keystore_alias = options[:keystore_alias] || ENV['ANDROID_KEYSTORE_ALIAS']
    keystore_password = options[:keystore_password] || ENV['ANDROID_KEYSTORE_PASSWORD']

    phraseapp
    gradle(
      task: 'assembleProd',
      properties: {
        'buildNumber' => build_number,
        'versionName' => version_name,
        'android.injected.signing.store.file' => keystore_path,
        'android.injected.signing.store.password' => keystore_password,
        'android.injected.signing.key.alias' => keystore_alias,
        'android.injected.signing.key.password' => keystore_password
      }
    )

    make_changelog
    if options[:publish_to_s3]
      upload_multiple_builds_to_s3(
        build_number: build_number,
        apk_files: lane_context[SharedValues::GRADLE_ALL_APK_OUTPUT_PATHS],
        build_info: options[:build_info]
      )
    end
  end

  desc 'Runs the tasks/lanes needed for releasing ready-for-testing android builds to s3 site'
  lane :release_build do |options|
    clean_dist
    build_number = options[:build_number] || 1
    generate_versions_file(build_number: build_number)
    version_name = get_version_name
    keystore_path = options[:keystore_path] || ENV['ANDROID_KEYSTORE_PATH']
    keystore_alias = options[:keystore_alias] || ENV['ANDROID_KEYSTORE_ALIAS']
    keystore_password = options[:keystore_password] || ENV['ANDROID_KEYSTORE_PASSWORD']

    phraseapp
    gradle(
      task: 'assembleRelease',
      properties: {
        'buildNumber' => build_number,
        'versionName' => version_name,
        'android.injected.signing.store.file' => keystore_path,
        'android.injected.signing.store.password' => keystore_password,
        'android.injected.signing.key.alias' => keystore_alias,
        'android.injected.signing.key.password' => keystore_password
      }
    )

    make_changelog
    if options[:publish_to_s3]
      upload_multiple_builds_to_s3(
        build_number: build_number,
        apk_files: lane_context[SharedValues::GRADLE_ALL_APK_OUTPUT_PATHS],
        build_info: options[:build_info]
      )
    end
  end

  desc 'For CI use. Versioning helper script.'
  lane :cat_tag_name do
    if File.exist?('tag_name.txt')
      File.open('tag_name.txt').read.strip
    elsif ENV['CI_BUILD_TYPE'] != 'review' && get_version_name
      "#{ENV['CI_BUILD_TYPE']}/#{get_version_name}"
    else
      '--'
    end
  end

  desc 'A wrapper for aws_s3 plugin with slack notification'
  lane :upload_apk_to_s3 do |options|
    app_directory = options[:app_directory] || "android/Release/#{options[:flavor]}/#{get_version_classifer}"
    aws_s3(
      access_key: options[:s3_access_key] || ENV['S3_ACCESS_KEY'],
      secret_access_key: options[:s3_secret_access_key] || ENV['S3_SECRET_ACCESS_KEY'],
      bucket: options[:s3_bucket] || ENV['S3_BUCKET'],
      region: options[:s3_region] || ENV['S3_REGION'],
      apk: options[:apk_file],
      app_directory: app_directory,
      upload_metadata: true
    )

    # set slack channel and payload
    apk_name = options[:apk_file].split('/').last
    slack_channel =
      case apk_name
      when /.*[vV]italityActive-release.*/ then 'android-ca-build'
      when /.*[sS]umitomo-release.*/ then 'android-sli-build'
      when /.*[uU][kK]essentials-release.*/ then 'android-uke-build'
      when /.*[iI][gG][iI]-release.*/ then 'android-igi-build'
      else 'android-code-review'
      end

    case apk_name
    when /.*[vV]itality.*/
      extra_message = ':flag-za: Vitality Active'
      changelog = File.open('CA_CHANGELOG.md').read.strip if File.file?('CA_CHANGELOG.md')
    when /.*[sS]umitomo.*/
      extra_message = ':flag-jp: Sumitomo'
      changelog = File.open('SLI_CHANGELOG.md').read.strip if File.file?('SLI_CHANGELOG.md')
    when /.*[uU][kK].*/
      extra_message = ':flag-gb: UK Essentials'
      changelog = File.open('UKE_CHANGELOG.md').read.strip if File.file?('UKE_CHANGELOG.md')
    when /.*[iI][gG][iI].*/
      extra_message = ':flag-pk: IGI'
      changelog = File.open('IGI_CHANGELOG.md').read.strip if File.file?('IGI_CHANGELOG.md')
    else
      extra_message = ':computer: DEV Flavor'
      changelog = File.open('FULL_CHANGELOG.md').read.strip if File.file?('FULL_CHANGELOG.md')
    end

    UI.message('Printing changelog..')
    UI.message(changelog)

    slack(
      message: ":rocket: #{extra_message} Deployment for Android "\
        "<#{lane_context[SharedValues::S3_HTML_OUTPUT_PATH]}|Installer> & "\
        "<#{lane_context[SharedValues::S3_APK_OUTPUT_PATH]}|Direct download>",
      channel: ENV['CI_SLACK_CHANNEL'] || slack_channel,
      success: true,
      payload: {
        'Version name' => get_version_name,
        'Version code' => get_version_code,
        'Git Version Tag' => cat_tag_name,
        'Changelog' => changelog || ' ',
        'Build Info' => options[:build_info] || "Built from #{git_branch} branch"
      },
      default_payloads: []
    )
  end

  desc 'A wrapper for upload_apk_to_s3 for uploading multiple apk files'
  lane :upload_multiple_builds_to_s3 do |options|
    apk_files = options[:apk_files]
    apk_files.each do |apk_file|
      apk_name = apk_file.split('/').last.sub!('.apk', '')
      next if apk_name =~ /.*app-dev.*/
      s3_root_directory = 'android/for_review' if apk_name =~ /.*debug.*/
      s3_root_directory ||= case ENV['CI_BUILD_TYPE']
                            when 'adhoc' then 'android/Adhoc'
                            when 'ci' then 'android/CI'
                            when 'prod' then 'android/Prod'
                            else 'android/sandbox'
                            end
      s3_directory = "#{s3_root_directory}/#{apk_name}/#{options[:build_number]}"
      UI.message "Uploading #{apk_file} to s3 bucket directory #{s3_directory}"
      upload_apk_to_s3(
        apk_file: apk_file,
        apk_name: apk_name,
        app_directory: s3_directory,
        build_info: options[:build_info]
      )
    end
  end

  after_all do |lane|
  end

  error do |lane, exception|
    if ENV['SEND_ERROR_TO_SLACK']
      slack(
        channel: 'android-code-review',
        message: exception.message,
        success: false
      )
    end
  end
end
